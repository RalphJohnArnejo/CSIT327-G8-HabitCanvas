{% extends "main/base.html" %}
{% load static %}

{% block content %}

<section class="dashboard-section" aria-labelledby="timerTitle">
    <div class="page-container">
        <div class="header-row">
            <div>
                <h2 id="timerTitle">Focus Timer</h2>
                <p class="subtext">Use the Pomodoro technique to stay focused</p>
            </div>
        </div>

        <div class="task-card timer-card" aria-label="Focus Timer">
            <div class="title-area">
                <div>
                    <p class="subtitle">Customize your focus and break sessions</p>
                </div>

                <div class="top-buttons">
                    <button id="openStats" class="top-btn"><i class="fa fa-chart-line"></i> Stats</button>
                    <button id="openSettings" class="top-btn"><i class="fa fa-gear"></i> Settings</button>
                </div>
            </div>

            <div class="mode-buttons" role="tablist" aria-label="timer modes">
                <button id="focusMode" class="mode-btn active-mode" role="tab" aria-selected="true"><i class="fa fa-leaf"></i> Focus</button>
                <button id="shortMode" class="mode-btn" role="tab" aria-selected="false"><i class="fa fa-mug-hot"></i> Short Break</button>
                <button id="longMode" class="mode-btn" role="tab" aria-selected="false"><i class="fa fa-bed"></i> Long Break</button>
            </div>

            <div class="timer-wrapper" aria-hidden="false">
                <div class="timer-circle" id="timerCircle" aria-live="polite">
                    <div class="timer-inner" id="timer">25:00</div>
                </div>
            </div>

            <div class="controls">
                <button id="startBtn" class="ctrl-btn start"><i class="fa fa-play"></i> Start</button>
                <button id="pauseBtn" class="ctrl-btn pause"><i class="fa fa-pause"></i> Pause</button>
                <button id="stopBtn" class="ctrl-btn stop"><i class="fa fa-stop"></i> Stop</button>
                <button id="resetBtn" class="ctrl-btn reset"><i class="fa fa-rotate-left"></i> Reset</button>
            </div>
        </div>
    </div>
</section>

<!-- SETTINGS MODAL -->
<div id="settingsModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-content" role="document">
        <span id="closeSettings" class="close" title="Close">&times;</span>
        <h2>Timer Settings</h2>

        <div class="settings-body">
            <div class="setting-row">
                <div class="label">Focus Duration</div>
                <div class="slider-wrap">
                    <input id="focusRange" type="range" min="1" max="60" step="1" value="25">
                    <div class="slider-value" id="focusVal">25 min</div>
                </div>
            </div>

            <div class="setting-row">
                <div class="label">Short Break</div>
                <div class="slider-wrap">
                    <input id="shortRange" type="range" min="1" max="60" step="1" value="5">
                    <div class="slider-value" id="shortVal">5 min</div>
                </div>
            </div>

            <div class="setting-row">
                <div class="label">Long Break</div>
                <div class="slider-wrap">
                    <input id="longRange" type="range" min="1" max="60" step="1" value="15">
                    <div class="slider-value" id="longVal">15 min</div>
                </div>
            </div>

            <div class="settings-divider"></div>

            <div class="option-row">
                <label>
                    <div class="toggle" id="soundToggle"><div class="dot"></div></div>
                    <span>Ticking &amp; End Sound</span>
                </label>

                <label class="settings-option-right">
                    <div class="toggle" id="notifToggle"><div class="dot"></div></div>
                    <span>Desktop Notifications</span>
                </label>
            </div>

            <button id="resetDefault" class="reset-default">Reset to defaults</button>

            <div class="settings-footer">
                <button id="cancelSettings" class="btn-cancel">Cancel</button>
                <button id="saveSettings" class="btn-save">Save Settings</button>
            </div>
        </div>
    </div>
</div>

<!-- STATS MODAL -->
<div id="statsModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-content" role="document">
        <span id="closeStats" class="close" title="Close">&times;</span>
        <h2>Stats</h2>

        <div class="stats-cards">
            <div class="stat-card blue">
                <div class="stat-small">Today's Focus Time</div>
                <div class="stat-big" id="todayMinutes">0 min</div>
                <div class="stat-extra" id="todaySessions">0 sessions completed</div>
            </div>

            <div class="stat-card green">
                <div class="stat-small">This Week</div>
                <div class="stat-big" id="weekMinutes">0 min</div>
                <div class="stat-extra" id="weekSessions">0 sessions completed</div>
            </div>

            <div class="stats-reset-row">
                <button id="clearStats" class="top-btn" title="Clear stats">Reset Stats</button>
            </div>
        </div>
    </div>
</div>

<div id="modeConfirmModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-content" role="document">
        <span id="modeConfirmClose" class="close" title="Close">&times;</span>
        <h2>Switch Timer Mode?</h2>

        <div class="settings-body">
            <p id="modeConfirmText" class="mode-confirm-text">
                You have a timer in progress. Switching modes will stop it and reset the timer.
            </p>

            <div class="settings-footer">
                <button id="modeConfirmCancel" class="btn-cancel">Cancel</button>
                <button id="modeConfirmOk" class="btn-save">Switch Mode</button>
            </div>
        </div>
    </div>
</div>

<script>
/* ===== Helper utilities ===== */
const $ = id => document.getElementById(id);

function formatTime(seconds){
    const m = Math.floor(seconds/60);
    const s = seconds % 60;
    return `${m}:${String(s).padStart(2,'0')}`;
}

function todayKey(){
    const d = new Date();
    return d.toISOString().slice(0,10); // YYYY-MM-DD
}

function weekKeys(){
    // returns array of last 7 day keys (including today)
    const keys = [];
    const now = new Date();
    for(let i=0;i<7;i++){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
        keys.push(d.toISOString().slice(0,10));
    }
    return keys;
}

/* ===== Persisted data keys ===== */
const STORAGE = {
    SETTINGS: 'habit_timer_settings_v1',
    STATE: 'habit_timer_state_v1',
    STATS: 'habit_timer_stats_v1'
};

/* ===== Default values ===== */
const DEFAULTS = {
    focus:25, short:5, long:15,
    sound:true,
    notifications:false
};

/* ===== Load / Save Settings ===== */
function loadSettingsFromStorage(){
    const raw = localStorage.getItem(STORAGE.SETTINGS);
    if(!raw) return {...DEFAULTS};
    try {
        const parsed = JSON.parse(raw);
        return {
        focus: Number.isFinite(parsed.focus) ? parsed.focus : parseInt(parsed.focus) || DEFAULTS.focus,
        short: Number.isFinite(parsed.short) ? parsed.short : parseInt(parsed.short) || DEFAULTS.short,
        long: Number.isFinite(parsed.long) ? parsed.long : parseInt(parsed.long) || DEFAULTS.long,
        sound: typeof parsed.sound === 'boolean' ? parsed.sound : DEFAULTS.sound,
        notifications: typeof parsed.notifications === 'boolean' ? parsed.notifications : DEFAULTS.notifications
    };

    } catch(e){
        return {...DEFAULTS};
    }
}

function saveSettingsToStorage(settings){
    localStorage.setItem(STORAGE.SETTINGS, JSON.stringify(settings));
}

/* ===== Stats storage =====
   stats structure:
   {
     'YYYY-MM-DD': { minutes: N, sessions: M },
     ...
   }
*/
function loadStats(){
    const raw = localStorage.getItem(STORAGE.STATS);
    if(!raw) return {};
    try { return JSON.parse(raw)||{} } catch(e){ return {} }
}
function saveStats(stats){
    localStorage.setItem(STORAGE.STATS, JSON.stringify(stats));
}

/* ===== State storage (timer running / last mode / timeLeft or endTime) =====
   state example:
   {
     currentMode: 'focus'|'short'|'long',
     isRunning: true|false,
     endTime: 169...  (ms since epoch)  OR timeLeftSeconds: 1500
   }
*/
function loadState(){ try { return JSON.parse(localStorage.getItem(STORAGE.STATE))||{} } catch(e){ return {} } }
function saveState(state){ localStorage.setItem(STORAGE.STATE, JSON.stringify(state)); }

/* ===== WebAudio sounds (tick + end) ===== */
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function playTickSound(){
    const s = settings.sound;
    if(!s) return;
    if(!AudioContext) return;
    if(!audioCtx) audioCtx = new AudioContext();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = 900;
    g.gain.value = 0.000001; // nearly silent initially
    o.connect(g);
    g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.00001, now);
    g.gain.exponentialRampToValueAtTime(0.02, now + 0.001);
    o.start(now);
    g.gain.exponentialRampToValueAtTime(0.00001, now + 0.06);
    o.stop(now + 0.07);
}

function playEndSound(){
    const s = settings.sound;
    if(!s) return;
    if(!AudioContext) return;
    if(!audioCtx) audioCtx = new AudioContext();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 520;
    o.connect(g);
    g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.00001, now);
    g.gain.exponentialRampToValueAtTime(0.18, now + 0.02);
    o.start(now);
    o.frequency.exponentialRampToValueAtTime(220, now + 0.25);
    g.gain.exponentialRampToValueAtTime(0.00001, now + 0.6);
    o.stop(now + 0.65);
}

/* ===== Notifications helper ===== */
async function requestNotificationPermission(){
    if(!("Notification" in window)) return false;
    const perm = await Notification.requestPermission();
    return perm === 'granted';
}
function sendNotification(title, body){
    if(!settings.notifications) return;
    if(!("Notification" in window)) return;
    if(Notification.permission !== 'granted') return;
    try {
        new Notification(title, { body, icon: '' });
    } catch(e){}
}

/* ===== Application state variables ===== */
let settings = loadSettingsFromStorage();
let stats = loadStats();
let state = loadState();

// DOM elements
const focusRange = $('focusRange');
const shortRange = $('shortRange');
const longRange = $('longRange');
const focusVal = $('focusVal');
const shortVal = $('shortVal');
const longVal = $('longVal');

const soundToggle = $('soundToggle');
const notifToggle = $('notifToggle');
const resetDefaultBtn = $('resetDefault');

const settingsModal = $('settingsModal');
const openSettingsBtn = $('openSettings');
const closeSettingsBtn = $('closeSettings');
const cancelSettingsBtn = $('cancelSettings');
const saveSettingsBtn = $('saveSettings');

const statsModal = $('statsModal');
const openStatsBtn = $('openStats');
const closeStatsBtn = $('closeStats');
const clearStatsBtn = $('clearStats');

const timerEl = $('timer');
const timerCircle = $('timerCircle');

const startBtn = $('startBtn');
const pauseBtn = $('pauseBtn');
const stopBtn = $('stopBtn');
const resetBtn = $('resetBtn');

const focusModeBtn = $('focusMode');
const shortModeBtn = $('shortMode');
const longModeBtn = $('longMode');

const todayMinutesEl = $('todayMinutes');
const todaySessionsEl = $('todaySessions');
const weekMinutesEl = $('weekMinutes');
const weekSessionsEl = $('weekSessions');

const modeConfirmModal = $('modeConfirmModal');
const modeConfirmText = $('modeConfirmText');
const modeConfirmClose = $('modeConfirmClose');
const modeConfirmCancel = $('modeConfirmCancel');
const modeConfirmOk = $('modeConfirmOk');

let pendingMode = null;


/* ===== Setup UI from settings ===== */
function applySettingsToControls(){
    focusRange.value = settings.focus;
    shortRange.value = settings.short;
    longRange.value = settings.long;
    focusVal.textContent = `${settings.focus} min`;
    shortVal.textContent = `${settings.short} min`;
    longVal.textContent = `${settings.long} min`;

    // toggles
    if(settings.sound) soundToggle.classList.add('on'); else soundToggle.classList.remove('on');
    if(settings.notifications) notifToggle.classList.add('on'); else notifToggle.classList.remove('on');
}
applySettingsToControls();

/* ===== Stats UI refresh ===== */
function refreshStatsUI(){
    const key = todayKey();
    const today = stats[key] || {minutes:0, sessions:0};
    todayMinutesEl.textContent = `${today.minutes} min`;
    todaySessionsEl.textContent = `${today.sessions} sessions completed`;

    const weekKeysArr = weekKeys();
    let wkMinutes = 0, wkSessions = 0;
    for(const k of weekKeysArr){
        const s = stats[k];
        if(s){ wkMinutes += (s.minutes||0); wkSessions += (s.sessions||0); }
    }
    weekMinutesEl.textContent = `${wkMinutes} min`;
    weekSessionsEl.textContent = `${wkSessions} sessions completed`;
}
refreshStatsUI();

/* ===== Timer logic (with Web Worker for background support) ===== */
let timerInterval = null;
let timerWorker = null;
let currentMode = state.currentMode || 'focus'; // focus|short|long
let isRunning = !!state.isRunning;
let endTime = state.endTime || null; // ms epoch when timer will end
let timeLeftSeconds = state.timeLeftSeconds || (settings.focus * 60); // fallback
let lastTickTime = 0; // For throttling tick sounds

// Initialize Web Worker for background timer support
function initTimerWorker() {
    if (typeof Worker !== 'undefined') {
        try {
            timerWorker = new Worker("{% static 'js/timer-worker.js' %}");
            
            timerWorker.onmessage = function(e) {
                const { type, timeLeft, isRunning: workerRunning } = e.data;
                
                switch(type) {
                    case 'tick':
                        timeLeftSeconds = timeLeft;
                        updateTimerDisplay();
                        // Throttle tick sound to once per second
                        const now = Date.now();
                        if (settings.sound && now - lastTickTime >= 900) {
                            playTickSound();
                            lastTickTime = now;
                        }
                        break;
                    case 'finished':
                        timeLeftSeconds = 0;
                        isRunning = false;
                        endTime = null;
                        timerCircle.classList.remove('running');
                        updateTimerDisplay();
                        state = { currentMode, isRunning: false, timeLeftSeconds: 0 };
                        saveStateToStorage();
                        onTimerFinish();
                        break;
                    case 'paused':
                        timeLeftSeconds = timeLeft;
                        isRunning = false;
                        endTime = null;
                        timerCircle.classList.remove('running');
                        updateTimerDisplay();
                        saveStateToStorage();
                        break;
                    case 'stopped':
                        isRunning = false;
                        endTime = null;
                        timerCircle.classList.remove('running');
                        break;
                    case 'state':
                        // Sync state from worker
                        if (e.data.isRunning) {
                            isRunning = true;
                            timeLeftSeconds = e.data.timeLeft;
                            endTime = e.data.endTime;
                            timerCircle.classList.add('running');
                        }
                        updateTimerDisplay();
                        break;
                }
            };
            
            timerWorker.onerror = function(err) {
                console.warn('Timer worker error, falling back to main thread:', err);
                timerWorker = null;
            };
            
            console.log('Timer Web Worker initialized for background support');
        } catch (err) {
            console.warn('Could not initialize Web Worker:', err);
            timerWorker = null;
        }
    }
}

// Initialize worker
initTimerWorker();

// initialize durations from settings object
function durationsFromSettings(){
    return { focus: settings.focus, short: settings.short, long: settings.long };
}
let durations = durationsFromSettings();

// When the page loads, if there's a running endTime in storage, compute timeLeftSeconds accordingly.
function restoreStateOnLoad(){
    // update durations from settings (in case saved)
    durations = durationsFromSettings();

    if(state && state.isRunning && state.endTime){
        const remainingMs = Number(state.endTime) - Date.now();
        if(remainingMs <= 0){
            // Timer already finished while user was away, treat as finished
            timeLeftSeconds = 0;
            isRunning = false;
            endTime = null;
            state = {};
            saveStateToStorage();
            onTimerFinish();
        } else {
            timeLeftSeconds = Math.ceil(remainingMs / 1000);
            startInterval(true); // resume and don't re-save endTime here (already set)
        }
    } else {
        // not running — restore last mode and either timeLeft or default
        if(state && state.currentMode){
            currentMode = state.currentMode;
        }
        // If there was a paused timeLeft saved, pick that. Otherwise set default for mode
        if(state && typeof state.timeLeftSeconds === 'number'){
            timeLeftSeconds = state.timeLeftSeconds;
        } else {
            timeLeftSeconds = durations[currentMode]*60;
        }
    }
    applyModeUI();
    updateTimerDisplay();
}
restoreStateOnLoad();

function saveStateToStorage(){
    const st = {
        currentMode,
        isRunning,
    };
    if(isRunning && endTime) st.endTime = endTime;
    else st.timeLeftSeconds = timeLeftSeconds;
    saveState(st);
}

/* update UI for active mode buttons */
function applyModeUI(){
    focusModeBtn.classList.toggle('active-mode', currentMode === 'focus');
    shortModeBtn.classList.toggle('active-mode', currentMode === 'short');
    longModeBtn.classList.toggle('active-mode', currentMode === 'long');
    focusModeBtn.setAttribute('aria-selected', currentMode === 'focus');
    shortModeBtn.setAttribute('aria-selected', currentMode === 'short');
    longModeBtn.setAttribute('aria-selected', currentMode === 'long');
}

/* update timer inner text */
function updateTimerDisplay(){
    timerEl.textContent = formatTime(timeLeftSeconds);
    // Update page title with timer (useful when tab is in background)
    document.title = `${formatTime(timeLeftSeconds)} - HabitCanvas Timer`;
}

/* start timer interval
   resumeFromStorage flag used to indicate restore from saved endTime (so we avoid re-saving endTime incorrectly)
*/
function startInterval(resumeFromStorage=false){
    if(isRunning && timerInterval) return; // already running
    isRunning = true;
    timerCircle.classList.add('running');

    // if not resuming (i.e. user hits Start), compute endTime and persist
    if(!resumeFromStorage){
        endTime = Date.now() + timeLeftSeconds * 1000;
        saveStateToStorage();
    } else {
        // resumeFromStorage: endTime already set from storage
        endTime = state.endTime;
    }

    // Use Web Worker if available for background support
    if (timerWorker) {
        timerWorker.postMessage({
            action: 'start',
            data: { endTime: endTime }
        });
        // Also run a fallback interval for when worker messages are delayed
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            // Fallback sync from localStorage endTime
            const remaining = Math.ceil((endTime - Date.now()) / 1000);
            if (remaining <= 0 && isRunning) {
                // Worker should handle this, but just in case
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }, 5000);
    } else {
        // Fallback: use main thread interval
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(()=>{
            const remaining = Math.ceil((endTime - Date.now()) / 1000);
            if(remaining <= 0){
                // finished
                timeLeftSeconds = 0;
                updateTimerDisplay();
                clearInterval(timerInterval);
                timerInterval = null;
                isRunning = false;
                timerCircle.classList.remove('running');
                // clear saved running state in storage
                state = { currentMode, isRunning:false, timeLeftSeconds:0 };
                saveStateToStorage();
                onTimerFinish();
            } else {
                timeLeftSeconds = remaining;
                updateTimerDisplay();
                // tick sound (every second)
                if(settings.sound) playTickSound();
            }
        }, 1000);
    }

    // save state
    saveStateToStorage();
}

/* stop/pause/stop timer */
function pauseTimer(){
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = null;
    
    // Tell worker to pause
    if (timerWorker) {
        timerWorker.postMessage({ action: 'pause' });
    }
    
    isRunning = false;
    timerCircle.classList.remove('running');
    // compute current timeLeftSeconds from endTime if present
    if(endTime){
        const remaining = Math.ceil((endTime - Date.now()) / 1000);
        timeLeftSeconds = Math.max(0, remaining);
    }
    endTime = null;
    saveStateToStorage();
    updateTimerDisplay();
}

function stopTimerAndReset(){
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = null;
    
    // Tell worker to stop
    if (timerWorker) {
        timerWorker.postMessage({ action: 'stop' });
    }
    
    isRunning = false;
    timerCircle.classList.remove('running');
    timeLeftSeconds = durations[currentMode]*60;
    endTime = null;
    saveStateToStorage();
    updateTimerDisplay();
}

/* Handle visibility change - sync timer when tab becomes visible again */
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'visible') {
        // Tab is now visible - sync timer state from storage
        const savedState = loadState();
        if (savedState && savedState.isRunning && savedState.endTime) {
            const remaining = Math.ceil((savedState.endTime - Date.now()) / 1000);
            if (remaining <= 0) {
                // Timer finished while tab was hidden
                timeLeftSeconds = 0;
                isRunning = false;
                endTime = null;
                timerCircle.classList.remove('running');
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = null;
                state = { currentMode, isRunning: false, timeLeftSeconds: 0 };
                saveStateToStorage();
                onTimerFinish();
            } else {
                timeLeftSeconds = remaining;
                endTime = savedState.endTime;
                isRunning = true;
                timerCircle.classList.add('running');
                updateTimerDisplay();
                
                // Restart worker sync if needed
                if (timerWorker && !timerInterval) {
                    timerWorker.postMessage({
                        action: 'sync',
                        data: { isRunning: true, endTime: endTime }
                    });
                }
            }
        }
        updateTimerDisplay();
    }
});

function resetTimerToModeDefault(){
    timeLeftSeconds = durations[currentMode]*60;
    endTime = null;
    if(timerInterval){ clearInterval(timerInterval); timerInterval=null; }
    isRunning = false;
    timerCircle.classList.remove('running');
    saveStateToStorage();
    updateTimerDisplay();
}

/* when timer finishes */
function onTimerFinish(){
    // visual / sound / notification
    playEndSound();
    sendNotification("Pomodoro finished", (currentMode === 'focus') ? "Focus session completed." : "Break finished.");

    // Update stats ONLY if the finished session was a Focus session
    if(currentMode === 'focus'){
        const key = todayKey();
        stats[key] = stats[key] || { minutes:0, sessions:0 };
        const minutesToAdd = settings.focus; // record the configured focus minutes
        stats[key].minutes = (stats[key].minutes || 0) + minutesToAdd;
        stats[key].sessions = (stats[key].sessions || 0) + 1;
        saveStats(stats);
        refreshStatsUI();
    }

    // auto-switch: if finished focus -> go to short break (common UX) else back to focus
    if(currentMode === 'focus'){
        currentMode = 'short';
    } else {
        currentMode = 'focus';
    }
    // set timeLeft to new mode default
    durations = durationsFromSettings();
    timeLeftSeconds = durations[currentMode]*60;
    updateTimerDisplay();
    applyModeUI();
    // Save state (not running)
    saveStateToStorage();
}

/* ===== UI actions wiring ===== */
startBtn.addEventListener('click', ()=>{
    // if already running, ignore
    if(isRunning) return;
    // if paused, compute endTime from timeLeftSeconds
    endTime = Date.now() + timeLeftSeconds*1000;
    startInterval(false);
});

pauseBtn.addEventListener('click', ()=>{
    pauseTimer();
});

stopBtn.addEventListener('click', ()=>{
    stopTimerAndReset();
});

resetBtn.addEventListener('click', ()=>{
    resetTimerToModeDefault();
});

/* mode buttons */
focusModeBtn.addEventListener('click', () => {
    confirmAndSwitchMode('focus');
});

shortModeBtn.addEventListener('click', () => {
    confirmAndSwitchMode('short');
});

longModeBtn.addEventListener('click', () => {
    confirmAndSwitchMode('long');
});



/* ===== Settings modal behaviour ===== */
openSettingsBtn.addEventListener('click', ()=>{
    // populate settings controls from current settings
    applySettingsToControls();
    settingsModal.style.display = 'flex';
    settingsModal.setAttribute('aria-hidden', 'false');
});
function closeSettingsModal(){
    // restore controls reflect current saved settings (cancel restores)
    applySettingsToControls();
    settingsModal.style.display = 'none';
    settingsModal.setAttribute('aria-hidden','true');
}
closeSettingsBtn.addEventListener('click', closeSettingsModal);
cancelSettingsBtn.addEventListener('click', closeSettingsModal);

// slider live labels
focusRange.addEventListener('input', ()=> focusVal.textContent = `${focusRange.value} min`);
shortRange.addEventListener('input', ()=> shortVal.textContent = `${shortRange.value} min`);
longRange.addEventListener('input', ()=> longVal.textContent = `${longRange.value} min`);

// toggle small helpers
soundToggle.addEventListener('click', ()=>{
    soundToggle.classList.toggle('on');
});
notifToggle.addEventListener('click', async ()=>{
    // if enabling notifications and permission not granted, request
    const willEnable = !notifToggle.classList.contains('on');
    if(willEnable){
        const granted = await requestNotificationPermission();
        if(!granted){
            // keep it off
            notifToggle.classList.remove('on');
            alert('Desktop notification permission was not granted.');
            return;
        }
    }
    notifToggle.classList.toggle('on');
});

// reset defaults
resetDefaultBtn.addEventListener('click', ()=>{
    settings = {...DEFAULTS};
    applySettingsToControls();
});

// save settings
saveSettingsBtn.addEventListener('click', ()=> {
    // read UI controls (force numeric values)
    const newSettings = {
        focus: Math.max(1, Math.min(60, parseInt(focusRange.value || DEFAULTS.focus, 10))),
        short: Math.max(1, Math.min(60, parseInt(shortRange.value || DEFAULTS.short, 10))),
        long:  Math.max(1, Math.min(60, parseInt(longRange.value || DEFAULTS.long, 10))),
        sound: soundToggle.classList.contains('on'),
        notifications: notifToggle.classList.contains('on')
    };

    // helper to apply saved settings to runtime and UI
    function applyNewSettingsAndRefreshUI() {
        settings = newSettings;
        saveSettingsToStorage(settings);

        // refresh durations object used by timer logic
        durations = durationsFromSettings();

        // If timer is NOT running, update the visible timer immediately to the new duration
        if (!isRunning) {
            timeLeftSeconds = durations[currentMode] * 60;
        } else {
            // If timer is running, we recompute endTime so remaining reflects current timeLeftSeconds (optional)
            // Keep current behavior: don't forcibly reset running timer. If you want running timer to adjust:
            // endTime = Date.now() + timeLeftSeconds * 1000;
        }

        // update controls and displayed timer
        applySettingsToControls();
        updateTimerDisplay();

        // persist state and settings
        saveStateToStorage();
    }

    // If enabling notifications, ensure permission (existing logic, but using our helper)
    if (newSettings.notifications && "Notification" in window && Notification.permission !== 'granted') {
        requestNotificationPermission().then(granted => {
            if (!granted) {
                newSettings.notifications = false;
                notifToggle.classList.remove('on');
                alert('Notifications permission denied — disabled notifications in settings.');
            }
            applyNewSettingsAndRefreshUI();
            closeSettingsModal();
        }).catch(() => {
            // In case request fails, still apply settings without notifications
            newSettings.notifications = false;
            notifToggle.classList.remove('on');
            applyNewSettingsAndRefreshUI();
            closeSettingsModal();
        });
    } else {
        applyNewSettingsAndRefreshUI();
        closeSettingsModal();
    }
});






/* close modal when clicking on overlay outside box */
settingsModal.addEventListener('click', (e)=> { if(e.target === settingsModal) closeSettingsModal(); });

/* ===== Stats modal behaviour ===== */
openStatsBtn.addEventListener('click', ()=>{
    statsModal.style.display = 'flex';
    statsModal.setAttribute('aria-hidden','false');
});
closeStatsBtn.addEventListener('click', ()=> { statsModal.style.display='none'; statsModal.setAttribute('aria-hidden','true'); });
statsModal.addEventListener('click', (e)=>{ if(e.target === statsModal){ statsModal.style.display='none'; statsModal.setAttribute('aria-hidden','true'); } });

$('clearStats').addEventListener('click', ()=> {
    if(!confirm('Reset all saved stats?')) return;
    stats = {};
    saveStats(stats);
    refreshStatsUI();
});

/* ===== Update stats periodically and on changes (just in case) ===== */
window.addEventListener('storage', (e)=>{
    if(e.key === STORAGE.STATS){
        stats = loadStats();
        refreshStatsUI();
    }
});

/* Save state before unload so it persists */
window.addEventListener('beforeunload', ()=>{
    // If running, ensure we saved endTime
    if(isRunning && endTime){
        state = { currentMode, isRunning:true, endTime };
    } else {
        state = { currentMode, isRunning:false, timeLeftSeconds };
    }
    saveStateToStorage();
});

/* ensure UI initial values show current durations */
(function init(){
    // apply saved settings to controls and runtime durations
    settings = loadSettingsFromStorage();
    applySettingsToControls();
    durations = durationsFromSettings();

    // ensure toggle visuals reflect loaded settings
    if(settings.sound) soundToggle.classList.add('on'); else soundToggle.classList.remove('on');
    if(settings.notifications) notifToggle.classList.add('on'); else notifToggle.classList.remove('on');

    // restore last selected mode (if saved)
    if(state && state.currentMode) currentMode = state.currentMode;
    applyModeUI();

    // if there was a paused timeLeft saved, use it; else set to mode default
    if(state && typeof state.timeLeftSeconds === 'number' && !state.isRunning){
        timeLeftSeconds = state.timeLeftSeconds;
    } else if (!state || !state.timeLeftSeconds) {
        timeLeftSeconds = durations[currentMode]*60;
    }

    // If there was running state stored, restore above
    if(state && state.isRunning && state.endTime){
        // restore handled earlier in restoreStateOnLoad — but call again to be sure
        // (this double-call is harmless)
    }

    updateTimerDisplay();
    refreshStatsUI();
})();

function switchMode(newMode) {
    // Change mode first so stopTimerAndReset uses the new mode's duration
    currentMode = newMode;
    durations = durationsFromSettings(); // refresh in case settings changed

    // This will:
    // - clear interval
    // - tell the worker to stop
    // - set isRunning = false
    // - set timeLeftSeconds = durations[currentMode] * 60
    // - update display + save state
    stopTimerAndReset();

    // Update button active-state styling
    applyModeUI();

    // Save current mode explicitly (already done in stopTimerAndReset, but safe)
    saveStateToStorage();
}

function confirmAndSwitchMode(newMode) {
    if (currentMode === newMode) return;

    const labelMap = {
        focus: 'Focus',
        short: 'Short Break',
        long: 'Long Break'
    };

    const defaultSecondsForCurrent = durations[currentMode] * 60;
    const timerInProgress = isRunning || timeLeftSeconds !== defaultSecondsForCurrent;

    if (!timerInProgress) {
        switchMode(newMode);
        return;
    }

    pendingMode = newMode;

    const currentLabel = labelMap[currentMode] || 'current';
    const newLabel = labelMap[newMode] || 'new';

    modeConfirmText.textContent =
        `Switching to ${newLabel} will stop and reset the current timer.`;

    modeConfirmModal.style.display = 'flex';
    modeConfirmModal.setAttribute('aria-hidden', 'false');
}

function closeModeConfirmModal() {
    modeConfirmModal.style.display = 'none';
    modeConfirmModal.setAttribute('aria-hidden', 'true');
    pendingMode = null;
}

modeConfirmClose.addEventListener('click', closeModeConfirmModal);
modeConfirmCancel.addEventListener('click', closeModeConfirmModal);

modeConfirmOk.addEventListener('click', () => {
    if (pendingMode) {
        switchMode(pendingMode);
    }
    closeModeConfirmModal();
});

modeConfirmModal.addEventListener('click', (e) => {
    if (e.target === modeConfirmModal) {
        closeModeConfirmModal();
    }
});

</script>
{% endblock %}
